#!/bin/python

import astropy.units as u
import numpy as np
import yaml
import random
import math
import sys
import os
import scipy.optimize as opt
import matplotlib.pyplot as plt
from matplotlib import rcParams
from astropy.io import fits
from astropy import table

from desidithering import dithering as Dithering
import argparse
import time

is_plot = False

# general plotting options 
rcParams.update({'figure.autolayout': True})
my_cmap = plt.cm.jet
my_cmap.set_under('white',.01)
my_cmap.set_over('white', 300)
my_cmap.set_bad('white')

check_angles_primary   = { 0: [-30., -150.],
                           1: [-30., 90],
                           2: [-150., 90.],
                           3: [330., 210.] }
check_angles_secondary = { 0: {4: [60.0,  240.0, 330.0], 5: [120.0, 210.0, 300.0]},
                           1: {4: [60.0,  240.0, 330.0], 5: [0.0,   90.0,  180.0]},
                           2: {4: [120.0, 210.0, 300.0], 5: [0.0,   90.0,  180.0]},
                           3: {4: [60.0,  240.0, 330.0], 5: [120.0, 210.0, 300.0]} }

def run_simulation_triangulate(dithering, source, source_id, random_seeing_offsets, random_airmass_offsets, pos_rms):
    # generate the random offset but not reveal it to user until the end
    x_offset = tabled_x_offsets[source_id]
    y_offset = tabled_y_offsets[source_id]

    #print("Offsets are set to: ", x_offset, y_offset)
    #print("Focal coordinate: ", tabled_x_pos[source_id], tabled_y_pos[source_id])
    
    if pos_rms > 0:
        pos_x_err = np.random.normal(loc=0, scale=pos_rms, size=num_dithers)
        pos_y_err = np.random.normal(loc=0, scale=pos_rms, size=num_dithers)
    else:
        pos_x_err = np.zeros(num_dithers)
        pos_y_err = np.zeros(num_dithers)
        
    dithering.set_focal_position_simple(tabled_x_pos[source_id], tabled_y_pos[source_id])

    dithering.set_theta_0(-5.*u.deg)
    dithering.set_phi_0(10.*u.deg)
    SNR          = []
    signal       = []
    signal_noise = []
    x      = []
    y      = []

    focal_x = dithering.focal_x[0]
    focal_y = dithering.focal_y[0]

    # initial point
    dithering.place_fiber([x_offset+pos_x_err[0], y_offset+pos_y_err[0]])
    start_time = time.time()

    print(random_seeing_offsets)
    
    dithering.run_simulation(source_type, *source, report=False, \
                             seeing_fwhm_ref_offset=random_seeing_offsets[0], airmass_offset=random_airmass_offsets[0])
    
    SNR.append([np.median(dithering.SNR['b'][0]), np.median(dithering.SNR['r'][0]), np.median(dithering.SNR['z'][0])])
    signal.append([np.sum(dithering.signal['b'][0]), np.sum(dithering.signal['r'][0]), np.sum(dithering.signal['z'][0])])
    signal_noise.append([np.sqrt(np.sum(dithering.signal_noise['b'][0]**2)),
                         np.sqrt(np.sum(dithering.signal_noise['r'][0]**2)),
                         np.sqrt(np.sum(dithering.signal_noise['z'][0]**2))])
    x.append(0)
    y.append(0)

    # dithering starts here
    # it is a very simple method to find the maximum point
    # the optimal is with 6 measurements (including the initial measurement)
    # -- first dither
    x_dither = search_radius*np.cos(30.*u.deg)
    y_dither = search_radius*np.sin(30.*u.deg)

    dithering.place_fiber([x_offset+x_dither+pos_x_err[1], y_offset+y_dither+pos_y_err[1]])
    dithering.run_simulation(source_type, *source, report=False, \
                             seeing_fwhm_ref_offset=random_seeing_offsets[1], airmass_offset=random_airmass_offsets[1])
    SNR.append([np.median(dithering.SNR['b'][0]), np.median(dithering.SNR['r'][0]), np.median(dithering.SNR['z'][0])])
    signal.append([np.sum(dithering.signal['b'][0]), np.sum(dithering.signal['r'][0]), np.sum(dithering.signal['z'][0])])
    signal_noise.append([np.sqrt(np.sum(dithering.signal_noise['b'][0]**2)),
                         np.sqrt(np.sum(dithering.signal_noise['r'][0]**2)),
                         np.sqrt(np.sum(dithering.signal_noise['z'][0]**2))])
    x.append(x_dither)
    y.append(y_dither)

    # -- second dither
    x_dither = -1*search_radius*np.cos(30.*u.deg)
    y_dither = search_radius*np.sin(30.*u.deg)
    dithering.place_fiber([x_offset+x_dither+pos_x_err[2], y_offset+y_dither+pos_y_err[2]])
    dithering.run_simulation(source_type, *source, report=False, \
                             seeing_fwhm_ref_offset=random_seeing_offsets[2], airmass_offset=random_airmass_offsets[2])
    SNR.append([np.median(dithering.SNR['b'][0]), np.median(dithering.SNR['r'][0]), np.median(dithering.SNR['z'][0])])
    signal.append([np.sum(dithering.signal['b'][0]), np.sum(dithering.signal['r'][0]), np.sum(dithering.signal['z'][0])])
    signal_noise.append([np.sqrt(np.sum(dithering.signal_noise['b'][0]**2)),
                         np.sqrt(np.sum(dithering.signal_noise['r'][0]**2)),
                         np.sqrt(np.sum(dithering.signal_noise['z'][0]**2))])
    x.append(x_dither)
    y.append(y_dither)
    
    # -- third dither
    x_dither = 0. 
    y_dither = -1*search_radius
    dithering.place_fiber([x_offset+x_dither+pos_x_err[3], y_offset+y_dither+pos_y_err[3]])
    dithering.run_simulation(source_type, *source, report=False, \
                             seeing_fwhm_ref_offset=random_seeing_offsets[3], airmass_offset=random_airmass_offsets[3])
    SNR.append([np.median(dithering.SNR['b'][0]), np.median(dithering.SNR['r'][0]), np.median(dithering.SNR['z'][0])])
    signal.append([np.sum(dithering.signal['b'][0]), np.sum(dithering.signal['r'][0]), np.sum(dithering.signal['z'][0])])
    signal_noise.append([np.sqrt(np.sum(dithering.signal_noise['b'][0]**2)),
                         np.sqrt(np.sum(dithering.signal_noise['r'][0]**2)),
                         np.sqrt(np.sum(dithering.signal_noise['z'][0]**2))])
    x.append(x_dither)
    y.append(y_dither)
    
    # -- next two dithering depends on the maximum among the ones searches
    max_idx = np.argmax(SNR)
    new_angles_primary   = check_angles_primary[max_idx]
    for i in range(2):
        x_dither = search_radius*np.cos(new_angles_primary[i]*u.deg)+x[max_idx]
        y_dither = search_radius*np.sin(new_angles_primary[i]*u.deg)+y[max_idx]

        dithering.place_fiber([x_offset+x_dither+pos_x_err[4+i], y_offset+y_dither+pos_y_err[4+i]])
        dithering.run_simulation(source_type, *source, report=False, \
                                 seeing_fwhm_ref_offset=random_seeing_offsets[4+i], airmass_offset=random_airmass_offsets[4+i])
        SNR.append([np.median(dithering.SNR['b'][0]), np.median(dithering.SNR['r'][0]), np.median(dithering.SNR['z'][0])])
        signal.append([np.sum(dithering.signal['b'][0]), np.sum(dithering.signal['r'][0]), np.sum(dithering.signal['z'][0])])
        signal_noise.append([np.sqrt(np.sum(dithering.signal_noise['b'][0]**2)),
                         np.sqrt(np.sum(dithering.signal_noise['r'][0]**2)),
                         np.sqrt(np.sum(dithering.signal_noise['z'][0]**2))])
        x.append(x_dither)
        y.append(y_dither)
            
    if(SNR[4]>SNR[5]):
        new_angles_secondary = check_angles_secondary[max_idx][4]
        max_idx2 = 4
    else:
        new_angles_secondary = check_angles_secondary[max_idx][5]
        max_idx2 = 5
    for i in range(3):
        x_dither = .75*search_radius*np.cos(new_angles_secondary[i]*u.deg) + x[max_idx2]
        y_dither = .75*search_radius*np.sin(new_angles_secondary[i]*u.deg) + y[max_idx2]
        dithering.place_fiber([x_offset+x_dither+pos_x_err[6+i], y_offset+y_dither+pos_y_err[6+i]])
        dithering.run_simulation(source_type, *source, report=False, \
                                 seeing_fwhm_ref_offset=random_seeing_offsets[6+i], airmass_offset=random_airmass_offsets[6+i])
        SNR.append([np.median(dithering.SNR['b'][0]), np.median(dithering.SNR['r'][0]), np.median(dithering.SNR['z'][0])])
        signal.append([np.sum(dithering.signal['b'][0]), np.sum(dithering.signal['r'][0]), np.sum(dithering.signal['z'][0])])
        signal_noise.append([np.sqrt(np.sum(dithering.signal_noise['b'][0]**2)),
                         np.sqrt(np.sum(dithering.signal_noise['r'][0]**2)),
                         np.sqrt(np.sum(dithering.signal_noise['z'][0]**2))])
        x.append(x_dither)
        y.append(y_dither)
        
    return x, y, signal, signal_noise, SNR

def run_simulation_rectangular(dithering, source, source_id, random_seeing_offsets, random_airmass_offsets, pos_rms, is_random=False):
    if not is_random:
        x_pos_moves = [0, -search_radius, 0,  search_radius, -search_radius, search_radius, -search_radius, 0,   search_radius]
        y_pos_moves = [0, search_radius, search_radius, search_radius, 0,   0,  -search_radius, -search_radius, -search_radius]
    else:
        x_pos_moves = np.concatenate( (np.asarray([0]), np.random.uniform(-search_radius, search_radius, num_dithers-1)) )
        y_pos_moves = np.concatenate( (np.asarray([0]), np.random.uniform(-search_radius, search_radius, num_dithers-1)) )

    # generate the random offset but not reveal it to user until the end
    x_offset = tabled_x_offsets[source_id]
    y_offset = tabled_y_offsets[source_id]
    if pos_rms > 0:
        pos_x_err = np.random.normal(loc=0, scale=pos_rms, size=num_dithers)
        pos_y_err = np.random.normal(loc=0, scale=pos_rms, size=num_dithers)
    else:
        pos_x_err = np.zeros(num_dithers)
        pos_y_err = np.zeros(num_dithers)

    #print("Offsets are set to: ", x_offset, y_offset)
    #print("Focal coordinate: ", tabled_x_pos[source_id], tabled_y_pos[source_id])
        
    dithering.set_focal_position_simple(tabled_x_pos[source_id], tabled_y_pos[source_id])
    dithering.place_fiber([x_offset, y_offset])
    dithering.set_theta_0(-5.*u.deg)
    dithering.set_phi_0(10.*u.deg)
    SNR          = []
    signal       = []
    signal_noise = []
    x        = []
    y        = []
    fluxvars = []
    #
    # dithering starts here
    # the positioner follows a rectangular pattern around the starting point
    #
    for i in range(len(x_pos_moves)):
        curr_fluxvar = np.random.uniform(-fluxvar, fluxvar)
        f_in[f_in==0] = 1e-12
        dithering.desi.source.update_in("F type star", "star",
                                        w_in*u.angstrom,
                                        f_in*(1+curr_fluxvar)*1e-17*u.erg/(u.angstrom*u.cm*u.cm*u.s))
        dithering.desi.source.update_out()
        dithering.place_fiber([x_offset+x_pos_moves[i]+pos_x_err[i], y_offset+y_pos_moves[i]+pos_y_err[i]])
        dithering.run_simulation(source_type, *source, report=False, \
                                 seeing_fwhm_ref_offset=random_seeing_offsets[i], \
                                 airmass_offset=random_airmass_offsets[i])
        SNR.append([np.median(dithering.SNR['b'][0]), np.median(dithering.SNR['r'][0]), np.median(dithering.SNR['z'][0])])
        signal.append([np.sum(dithering.signal['b'][0]), np.sum(dithering.signal['r'][0]), np.sum(dithering.signal['z'][0])])
        signal_noise.append([np.sqrt(np.sum(dithering.signal_noise['b'][0]**2)),
                             np.sqrt(np.sum(dithering.signal_noise['r'][0]**2)),
                             np.sqrt(np.sum(dithering.signal_noise['z'][0]**2))])
        x.append(x_pos_moves[i]+pos_x_err[i])
        y.append(y_pos_moves[i]+pos_y_err[i])
        fluxvars.append(curr_fluxvar)
        
    return x, y, signal, signal_noise, SNR, fluxvars

parser = argparse.ArgumentParser(description="Script to find the optimal focal point given a set of parameters")
parser.add_argument("--config",         dest="config", default="config/desi-noblur-nooffset.yaml")
parser.add_argument("--setid",          dest="setid",  default=0, type=int)
parser.add_argument("--step-size",      dest="stepsize",         type=float, required=True, help="Step size for the optimization algorithm")
parser.add_argument("--lookupTable",    dest="LUT",              type=str, required=True, help="The table file to run the analysis")
parser.add_argument("--systematic",     dest="systematicoffset", type=float, default=[0.0, 0.0], nargs=2)
parser.add_argument("--half-light-radius",   dest="half_light_radius", type=float,  default=0.5, help="Half width radius of the sources")
parser.add_argument("--seeing_offsets_rms",  dest="seeing_offsets",    type=float,  default=0.0, help="RMS of the seeing offsets")
parser.add_argument("--airmass_offsets_rms", dest="airmass_offsets",   type=float,  default=0.0, help="RMS of the airmass offsets")
parser.add_argument("--flux_variation",      dest="fluxvar",           type=float,  default=0.0, help="Flux variation in between dithers")
parser.add_argument("--number_of_fibers",    dest="num_sources",       type=int,    default=200, help="Number of fibers to simulate at once")
parser.add_argument("--positioner_rms",      dest="pos_rms",           type=float,  default=0.0, help="RMS of the positioner position")
parser.add_argument("--dithering_pattern",   dest="pattern",           type=int,    default=0,   help="Dithering pattern, 0: triangular, 1: rectangular, 2: random")
parser.add_argument("--num-dithers",         dest='num_dithers',       type=int,    default=9,  help='Number of dithering points')
parser.add_argument("--output",              dest="outfname",          type=str,    default="results")
parser.add_argument("--prefix",              dest="prefix",            type=str,    default="",  required=False, help="The prefix for the output directory")
parser.add_argument("--verbose",             dest='verbose',           type=int,    default=0)
parsed_args = parser.parse_args()

config_file       = parsed_args.config
setid             = parsed_args.setid
dithering         = Dithering.dithering(config_file=config_file)
dithering_pure    = Dithering.dithering(config_file=config_file)#"config/desi-noblur-nooffset.yaml")
search_radius     = parsed_args.stepsize
systematic_       = parsed_args.systematicoffset
half_light_radius = parsed_args.half_light_radius
num_sources       = parsed_args.num_sources
seeing_offset_rms = parsed_args.seeing_offsets
airmass_offset_rms= parsed_args.airmass_offsets
pos_rms           = parsed_args.pos_rms
outfname          = parsed_args.outfname
pattern           = parsed_args.pattern
LUT_filename      = parsed_args.LUT
prefix            = parsed_args.prefix
num_dithers       = parsed_args.num_dithers
fluxvar           = parsed_args.fluxvar

tabled_values = np.load(LUT_filename, allow_pickle=True)
tabled_x_pos  = tabled_values['x_pos'][setid*num_sources:(setid+1)*num_sources]
tabled_y_pos  = tabled_values['y_pos'][setid*num_sources:(setid+1)*num_sources]
tabled_x_offsets = tabled_values['x_offsets'][setid*num_sources:(setid+1)*num_sources]
tabled_y_offsets = tabled_values['y_offsets'][setid*num_sources:(setid+1)*num_sources]
tabled_wlens  = tabled_values["wlens"]
tabled_fluxes = tabled_values["fluxes"]
#tabled_mags   = tabled_values["mags"]

num_pointings = 1
num_total     = num_pointings * num_sources - 1
results_b     = []
real_values_b = []
results_r     = []
real_values_r = []
results_z     = []
real_values_z = []

try:
    import progressbar
    bar = progressbar.ProgressBar(max_value=num_total,
                                  widgets=[ ' [', progressbar.Timer(), '] ',
                                            progressbar.Bar(),
                                            ' (', progressbar.ETA(), ') ',])
    bar.update(0)
except:
    bar = None

# generate the random airmass offsets to be introduced
# depending on the arguments given, they will be either all zeros
# or they will have a gaussian distribution with a mean given in the config file
# and sigma provided by David's technical note
# same procedure will be followed for the seeing (using seeing_fwhm_ref)
# since all the measurements of an exposure of 500 fibers would be at the same time,
# there are only 9 offset values for each iteration of the algorithm
if seeing_offset_rms<0.0001:
    random_seeing_fwhm_ref_offsets = np.zeros(num_dithers)*u.arcsec
else:
    # TOLGA CHANGE HERE
    random_seeing_fwhm_ref_offsets = tabled_values['seeing_changes'][()][seeing_offset_rms]
          
if airmass_offset_rms<0.01:
    random_airmass_offsets         = np.zeros(num_dithers)
else:
    random_airmass_offsets         = np.random.normal(0., airmass_offset_rms, num_dithers)

# generate the fits file primary header
prihdr = fits.Header()
prihdr['COMMENT'] = "The config file used is {}.".format(config_file)
prihdu  = fits.PrimaryHDU(header=prihdr)
hdulist = fits.HDUList([prihdu])

for i in range(num_pointings):
    # define the observing conditions
    boresight_alt = random.uniform(10., 30.)
    boresight_az  = random.uniform(10., 30.)

    # here is what we will save in the fits file
    bore_alt = np.zeros(num_sources)
    bore_az  = np.zeros(num_sources)
    src_alt = np.zeros(num_sources)
    src_az  = np.zeros(num_sources)
    known_offset_x = np.zeros(num_sources)
    known_offset_y = np.zeros(num_sources)
    known_systematic_x = np.zeros(num_sources)
    known_systematic_y = np.zeros(num_sources)
    #magnitudes = np.zeros((num_sources, 5))
    calc_offset_x = np.zeros(num_sources)
    calc_offset_y = np.zeros(num_sources)
    calc_sigma_x = np.zeros(num_sources)
    calc_sigma_y = np.zeros(num_sources)
    known_snr_r = np.zeros(num_sources)
    known_snr_b = np.zeros(num_sources)
    known_snr_z = np.zeros(num_sources)
    calc_snr_r = np.zeros(num_sources)
    calc_snr_b = np.zeros(num_sources)
    calc_snr_z = np.zeros(num_sources)
    dither_xs  = np.zeros((num_sources,num_dithers))
    dither_ys  = np.zeros((num_sources,num_dithers))
    calc_snrs_b    = np.zeros((num_sources,num_dithers))
    calc_snrs_r    = np.zeros((num_sources,num_dithers))
    calc_snrs_z    = np.zeros((num_sources,num_dithers))
    calc_signals_b = np.zeros((num_sources,num_dithers))
    calc_signals_r = np.zeros((num_sources,num_dithers))
    calc_signals_z = np.zeros((num_sources,num_dithers))
    calc_signals_noise_b = np.zeros((num_sources,num_dithers))
    calc_signals_noise_r = np.zeros((num_sources,num_dithers))
    calc_signals_noise_z = np.zeros((num_sources,num_dithers))
    fluxvariations = np.zeros((num_sources,num_dithers))
    calc_signal_r = np.zeros(num_sources)
    calc_signal_b = np.zeros(num_sources)
    calc_signal_z = np.zeros(num_sources)
    known_signal_r = np.zeros(num_sources)
    known_signal_b = np.zeros(num_sources)
    known_signal_z = np.zeros(num_sources)
    focal_xs   = np.zeros(num_sources)
    focal_ys   = np.zeros(num_sources)
    fiber_ids  = np.zeros(num_sources)

    w_in = tabled_wlens[0]
    num_wavelengths = int(len(w_in)/10)
    w_first = w_in[0]
    w_last  = w_in[-1]
    f_ins = np.zeros((num_sources, num_wavelengths))
        
    # define the source to be observed
    source_type       = "qso"
    curr_time         = time.time()
    for j in range(num_sources):
        
        if bar is not None:
            bar.update((i+1)*j)
        else:
            if j%20==0:
                print("{}: {}/{}".format(-curr_time+time.time(), j, num_sources))
                curr_time = time.time()
                
        # Generate the source to be observed
        if source_type == "qso" or source_type == "QSO":
            source = dithering.generate_source(disk_fraction=0., bulge_fraction=0., 
                                               half_light_disk=0., half_light_bulge=0.)
        elif source_type == "elg" or source_type == "ELG":
            source = dithering.generate_source(disk_fraction=1., bulge_fraction=0., 
                                               half_light_disk=half_light_radius, half_light_bulge=0.)
        elif source_type == "lrg" or source_type == "LRG":
            source = dithering.generate_source(disk_fraction=0., bulge_fraction=1., 
                                               half_light_disk=0., half_light_bulge=half_light_radius)

        global f_in
        w_in = tabled_wlens[j]
        f_in = tabled_fluxes[j]
        #mag  = tabled_mags[j]

        #f_in[f_in==0] = 1e-12
        dithering.desi.source.update_in("F type star", "star",
                                        w_in*u.angstrom,
                                        f_in*1e-17*u.erg/(u.angstrom*u.cm*u.cm*u.s))
        dithering.desi.source.update_out()
        dithering_pure.desi.source.update_in("F type star", "star",
                                             w_in*u.angstrom,
                                             f_in*1e-17*u.erg/(u.angstrom*u.cm*u.cm*u.s))
        dithering_pure.desi.source.update_out()
        
        #try:
        if True:
            
            x_offset = tabled_x_offsets[j]
            y_offset = tabled_y_offsets[j]
            focal_x  = tabled_x_pos[j]
            focal_y  = tabled_y_pos[j]

            dithering_pure.set_focal_position_simple(tabled_x_pos[j], tabled_y_pos[j])
            dithering_pure.place_fiber([0., 0.])
            dithering_pure.set_theta_0(-5.*u.deg)
            dithering_pure.set_phi_0(10.*u.deg)
            dithering_pure.run_simulation(source_type, *source, report=False, \
                                          seeing_fwhm_ref_offset=1e-12*u.arcsec, airmass_offset=1e-12)

            if pattern == 1:
                xs, ys, signals, signals_noise, SNRs, flxuvars = run_simulation_rectangular(dithering, source, j,
                                                                                            random_seeing_fwhm_ref_offsets,
                                                                                            random_airmass_offsets, pos_rms)
            elif pattern == 0:
                xs, ys, signals, signals_noise, SNRs, fluxvars = run_simulation_triangulate(dithering, source, j,
                                                                                            random_seeing_fwhm_ref_offsets,
                                                                                            random_airmass_offsets, pos_rms)
            else:
                xs, ys, signals, signals_noise, SNRs, fluxvars = run_simulation_rectangular(dithering, source, j,
                                                                                            random_seeing_fwhm_ref_offsets,
                                                                                            random_airmass_offsets, pos_rms, is_random=True)

            signals = np.asarray(signals)
            signals_noise = np.asarray(signals_noise)
            SNRs    = np.asarray(SNRs)
            
            focal_xs[j] = focal_x
            focal_ys[j] = focal_y
            known_offset_x[j] = x_offset
            known_offset_y[j] = y_offset
            known_systematic_x[j] = systematic_[0]
            known_systematic_y[j] = systematic_[1]
            #magnitudes[j] = np.array(mag)

            fiber_ids[j] = setid*num_sources + j
            # for some reason, (i don't care for now) there is sometimes
            # error with the size of the array. TODO: Take a look at this later.
            try:
                f_ins[j] = f_in[::10]
            except:
                f_ins[j] = f_in[1::10]
                
            dither_xs[j]    = np.array(xs)
            dither_ys[j]    = np.array(ys)
            calc_snrs_b[j]    = np.array(SNRs.T[0])
            calc_snrs_r[j]    = np.array(SNRs.T[1])
            calc_snrs_z[j]    = np.array(SNRs.T[2])
            calc_signals_b[j] = np.array(signals.T[0])
            calc_signals_r[j] = np.array(signals.T[1])
            calc_signals_z[j] = np.array(signals.T[2])
            calc_signals_noise_b[j] = np.array(signals_noise.T[0])
            calc_signals_noise_r[j] = np.array(signals_noise.T[1])
            calc_signals_noise_z[j] = np.array(signals_noise.T[2])
            
            calc_snr_b[j] = (np.median(dithering.SNR['b'][0]))
            calc_snr_r[j] = (np.median(dithering.SNR['r'][0]))
            calc_snr_z[j] = (np.median(dithering.SNR['z'][0]))
            calc_signal_b[j] = (np.median(dithering.signal['b'][0]))
            calc_signal_r[j] = (np.median(dithering.signal['r'][0]))
            calc_signal_z[j] = (np.median(dithering.signal['z'][0]))

            fluxvariations[j] = fluxvars
            
            known_snr_b[j] = (np.median(dithering_pure.SNR['b'][0]))
            known_snr_r[j] = (np.median(dithering_pure.SNR['r'][0]))
            known_snr_z[j] = (np.median(dithering_pure.SNR['z'][0]))
            known_signal_b[j] = (np.sum(dithering_pure.signal['b'][0]))
            known_signal_r[j] = (np.sum(dithering_pure.signal['r'][0]))
            known_signal_z[j] = (np.sum(dithering_pure.signal['z'][0]))

            del focal_x, focal_y, x_offset, y_offset
            del f_in#, mag
            del xs, ys, SNRs, signals
            del dithering.SNR, dithering.signal
            #del dithering_pure.SNR, dithering_pure.signal
            
        #except:
        else:
            if parsed_args.verbose:
                print("problem with the current fiber dithering {}... moving to the next one...".format(j))
            continue
        
    hodor = fits.Header()
    hodor['airmass_offset_rms'] = airmass_offset_rms
    hodor['seeing_offset_rms']  = seeing_offset_rms
    hodor['search_radiuss']     = search_radius
    hodor['positioner_error']   = pos_rms
    hodor['first_wavelength']   = w_first
    hodor['last_wavelength']    = w_last
    hodor['num_wavelengths']    = num_wavelengths
    for idither in range(num_dithers):
        hodor['seeing_offset_{}'.format(idither)] = random_seeing_fwhm_ref_offsets[idither].value
        
    thdu = fits.BinTableHDU.from_columns(
        [fits.Column(name="fiber_ids",          array=fiber_ids, format="J"),
         fits.Column(name="boresight_alt",      array=bore_alt, format="E"),
         fits.Column(name="boresight_az",       array=bore_az, format="E"),
         fits.Column(name="source_alt",         array=src_alt, format="E"),
         fits.Column(name="source_az",          array=src_az, format="E"),
         fits.Column(name="known_offset_x",     array=known_offset_x, format="E"),
         fits.Column(name="known_offset_y",     array=known_offset_y, format="E"),
         fits.Column(name="known_systematic_x", array=known_systematic_x, format="E"),
         fits.Column(name="known_systematic_y", array=known_systematic_y, format="E"),
         fits.Column(name="calc_offset_x",      array=calc_offset_x, format="E"),
         fits.Column(name="calc_offset_y",      array=calc_offset_y, format="E"),
         fits.Column(name="calc_sigma_x",       array=calc_sigma_x, format="E"),
         fits.Column(name="calc_sigma_y",       array=calc_sigma_y, format="E"),
         fits.Column(name="known_snr_b",        array=known_snr_b, format="E"),
         fits.Column(name="known_snr_r",        array=known_snr_r, format="E"),
         fits.Column(name="known_snr_z",        array=known_snr_z, format="E"),
         fits.Column(name="calc_snr_b",         array=calc_snr_b, format="E"),
         fits.Column(name="calc_snr_r",         array=calc_snr_r, format="E"),
         fits.Column(name="calc_snr_z",         array=calc_snr_z, format="E"),
         fits.Column(name="calc_snrs_b",        array=calc_snrs_b,  format="{}E".format(num_dithers)),
         fits.Column(name="calc_snrs_r",        array=calc_snrs_r,  format="{}E".format(num_dithers)),
         fits.Column(name="calc_snrs_z",        array=calc_snrs_z,  format="{}E".format(num_dithers)),
         fits.Column(name="known_signal_b",     array=known_signal_b, format="E"),
         fits.Column(name="known_signal_r",     array=known_signal_r, format="E"),
         fits.Column(name="known_signal_z",     array=known_signal_z, format="E"),
         fits.Column(name="calc_signal_b",      array=calc_signal_b, format="E"),
         fits.Column(name="calc_signal_r",      array=calc_signal_r, format="E"),
         fits.Column(name="calc_signal_z",      array=calc_signal_z, format="E"),
         fits.Column(name="dither_pos_x",       array=dither_xs,  format="{}E".format(num_dithers)),
         fits.Column(name="dither_pos_y",       array=dither_ys,  format="{}E".format(num_dithers)),
         fits.Column(name="calc_signals_b",     array=calc_signals_b,  format="{}E".format(num_dithers)),
         fits.Column(name="calc_signals_r",     array=calc_signals_r,  format="{}E".format(num_dithers)),
         fits.Column(name="calc_signals_z",     array=calc_signals_z,  format="{}E".format(num_dithers)),
         fits.Column(name="calc_signals_noise_b",array=calc_signals_noise_b,  format="{}E".format(num_dithers)),
         fits.Column(name="calc_signals_noise)r",array=calc_signals_noise_r,  format="{}E".format(num_dithers)),
         fits.Column(name="calc_signals_noise)z",array=calc_signals_noise_z,  format="{}E".format(num_dithers)),
         fits.Column(name="fluxvariations",     array=fluxvariations,  format="{}E".format(num_dithers)),
         fits.Column(name="focal_x",            array=focal_xs, format='E'),
         fits.Column(name="focal_y",            array=focal_ys, format="E"),
         #fits.Column(name="mag",                array=magnitudes, format="5E"),
         fits.Column(name="f_in",               array=f_ins, format="{}E".format(num_wavelengths)),
        ], header=hodor)
    hdulist.append(thdu)
    
try:
    print("making directory: {}/data".format(prefix))
    os.mkdir("{}/".format(prefix))
except:
    print("main folder exists... checking the subfolder...")

try:
    print("making directory: {}/data/{}um".format(prefix, search_radius))
    os.mkdir("{}/{}um".format(prefix, search_radius))
except:
    print("subfolder exists.. moving on to saving the file")

temp_filename = "{}/{}um/{}.fits".format(prefix, search_radius, outfname)
filename = temp_filename
trial = 1
while True:
    if os.path.exists(filename):
        filename = temp_filename.split(".fits")[0]+"_{}".format(trial)+".fits"
        trial = trial + 1
    else:
        break
print(filename)
hdulist.writeto(filename)
